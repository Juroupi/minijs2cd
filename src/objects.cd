type Value = Object | `null | `undefined | Int | Float | String | Bool

type Object = {
	properties = (ref {..});
	prototype = (ref (Object | `null));
	..
}

type FunctionObject = Object + { call = (Value -> [Value*] -> Value) }

type BigIntObject = Object + { big_int_data = Int }
type NumberObject = Object + { number_data = Float }
type StringObject = Object + { string_data = String }
type BooleanObject = Object + { boolean_data = Bool }

type PropertyOperators = {
	get = (Object -> (Value | `nil));
	set = (Object -> Value -> []);
	delete = (Object -> []);
}

let create_object (properties : {..}) (prototype : Object | `null) : Object = {
	properties = (ref {..} properties);
	prototype = (ref (Object | `null) prototype);
}

let object_prototype = create_object {} `null

let function_prototype = create_object {} object_prototype

let create_function (properties : {..}) (call : Value -> [Value*] -> Value) : FunctionObject =
	(create_object properties function_prototype) + { call }

let number_prototype = (create_object {} object_prototype) + { number_data = (float_of "0") }
let big_int_prototype = create_object {} object_prototype
let string_prototype = (create_object {} object_prototype) + { string_data = "" }
let boolean_prototype = (create_object {} object_prototype) + { boolean_data = `false }

let call (obj : Value) (this : Value) (params : [Value*]) : Value =
	match obj with
	| fobj & FunctionObject -> fobj.call this params
	| _ -> raise "TypeError"

let contains_property (obj : Value) (ops : PropertyOperators) : Value =
	let obj = to_object obj in
	match ops.get obj with
	| `nil -> (
		match !(obj.prototype) with
		| `null -> `false
		| prototype & Object -> contains_property prototype ops
	)
	| Value -> `true

let get_property (obj : Value) (ops : PropertyOperators) : Value =
	let obj = to_object obj in
	match ops.get obj with
	| `nil -> (
		match !(obj.prototype) with
		| `null -> `undefined
		| prototype & Object -> get_property prototype ops
	)
	| value & Value -> value

let set_property (obj : Value) (ops : PropertyOperators) (value : Value) : Value =
	let obj = to_object obj in
	ops.set obj value;
	`true

let delete_property (obj : Value) (ops : PropertyOperators) : Value =
	let obj = to_object obj in
	ops.delete obj;
	`true

let get_prototype_of (obj : Value) : Value =
	let obj = to_object obj in
	!(obj.prototype)

let set_prototype_of (obj : Value) (value : Value) : Value =
	let obj = to_object obj in
	match value with
	| value & (Object | `null) -> obj.prototype := value
	| _ -> raise "set_prototype_of"

let string_of_number (n : Float) : String =
	match string_of n with
	| [ s::((Char \ '.')*) '.' '0'* ] -> s
	| [ s::((Char \ '.')* '.' (Char \ '0')*) '0'* ] -> s
	| s -> s

let string_of_boolean (b : Bool) : String =
	if b then "true" else "false"

let to_object (value : Value) : Object =
	match value with
	| `undefined -> raise "TypeError: cannot convert undefined to object"
	| `null -> raise "TypeError: cannot convert null to object"
	| big_int_data & Int -> (create_object {} object_prototype) + { big_int_data }
	| number_data & Float -> (create_object {} object_prototype) + { number_data }
	| string_data & String -> (create_object {} object_prototype) + { string_data }
	| boolean_data & Bool -> (create_object {} object_prototype) + { boolean_data }
	| o & Object -> o

let to_boolean (value : Value) : Bool =
	not ((value = (float_of "NaN")) || (value = (float_of "0")) || (value = 0) || (value = `false) || (value = `null) || (value = `undefined) || (value = ""))

let type_of (value : Value) : String =
	match value with
	| `undefined -> "undefined"
	| `null -> "object"
	| Int -> "bigint"
	| Float -> "number"
	| String -> "string"
	| Bool -> "boolean"
	| FunctionObject -> "function"
	| Object -> "object"

let print_value (value : Value) : [] =
	match value with
	| FunctionObject -> print "\x1B;[36m[Function]\x1B;[0m"
	| o & NumberObject -> print_utf8 ("\x1B;[33m[Number: " @ string_of_number o.number_data @ "]\x1B;[0m")
	| o & BigIntObject -> print_utf8 ("\x1B;[33m[BigInt: " @ string_of o.big_int_data @ "n]\x1B;[0m")
	| o & BooleanObject -> print_utf8 ("\x1B;[33m[Boolean: " @ string_of_boolean o.boolean_data @ "]\x1B;[0m")
	| o & StringObject -> print_utf8 ("\x1B;[32m[String: '" @ o.string_data @ "']\x1B;[0m")
	| Object -> print "{}"
	| `null -> print "\x1B;[1mnull\x1B;[0m"
	| `undefined -> print "\x1B;[90mundefined\x1B;[0m"
	| x & Int -> print ("\x1B;[33m" @ (string_of x) @ "n\x1B;[0m")
	| x & Float -> print_utf8 ("\x1B;[33m" @ string_of_number x @ "\x1B;[0m")
	| x & String -> print_utf8 x
	| x -> print_utf8 ("\x1B;[33m" @ string_of_boolean x @ "\x1B;[0m")

let print_sequence (values : [Value*]) : `undefined =
	let _ = (map values with value -> (print_value value; print " ")) in
	print "\n";
	`undefined

let global_this = create_object {} object_prototype

let this = create_object {} object_prototype

let globalThis = ref (Object) global_this

let __Object__ = ref (FunctionObject) (
	create_function {} (
		fun (_ : Value) (params : [Value*]) : Value =
			match params with
			| [] -> create_object {} object_prototype
			| [ param _* ] -> to_object param
	))